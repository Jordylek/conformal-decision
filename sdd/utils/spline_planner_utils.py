import math
import numpy as np
import numba
import skfmm
import cv2

# Creates signed distance function to circle
#   X is meshgrid x-values
#   Y is meshgrid y-values
#   center is center of circle (in 2D)
#   rad is radius of circle.
def sd_circle(X, Y, center, rad):
  data = np.zeros([len(X), len(Y)])
  data = data + (X - center[0])**2 # this should be elementwise
  data = data + (Y - center[1])**2
  data = np.sqrt(data) - rad
  return data

# Creates signed distance function to rectangle
def sd_rect_by_corners(X, Y, lower, upper):
  # Implicit surface function calculation.
  # Compute the intersection (by max operator) of halfspaces.
  # NOTE: Each halfspace is generated by a signed distance function,
  # but the resulting intersection is not quite a signed distance function.
  data = np.maximum(X - upper[0], lower[0] - X)
  data = np.maximum(data, Y - upper[1])
  data = np.maximum(data, lower[1] - Y)

  return data

def sd_binary_image(binary_img):
    # Computes signed distance for binarized image.
    # First converts binary obstacles (+1) to (-1)
    # converts freespace (0) to (1)
    # Then runs skfmm to get signed distance func.
    binary_img = binary_img.astype('int8')
    binary_img[binary_img > 0] = -1
    binary_img[binary_img == 0] = 1
    data = skfmm.distance(binary_img)
    return data

def binarize_img(rgb_img, thresh, save_img=False):
    th, im_th = cv2.threshold(rgb_img, thresh, 255, cv2.THRESH_BINARY)
    if save_img:
        cv2.imwrite('../binarized_img.png', im_th)
    im_th = im_th > 0 # obstacles are not equal to zero
    return im_th

# Numba-compatible implementation of the inverse error function (erf_inv) using rational approximation
@numba.njit
def erf_inv_numba(y):
    a1, a2, a3, a4 =  0.886226899, -1.645349621,  0.914624893, -0.140543331
    b1, b2, b3, b4 = -2.118377725,  1.442710462, -0.329097515,  0.012229801
    c1, c2, c3, c4 = -1.970840454, -1.624906493,  3.429567803,  1.641345311
    d1, d2         =  3.543889200,  1.637067800
    
    abs_y = abs(y)
    
    if abs_y <= 0.7:
        z = y * y
        num = (((a4 * z + a3) * z + a2) * z + a1)
        den = ((((b4 * z + b3) * z + b2) * z + b1) * z + 1.0)
        return y * num / den
    
    z = math.sqrt(-math.log((1.0 - abs_y) / 2.0))
    num = ((c4 * z + c3) * z + c2) * z + c1
    den = (d2 * z + d1) * z + 1.0
    
    result = num / den
    return result if y > 0 else -result

# Numba-friendly std_normal_inv using erf_inv_numba
@numba.njit
def std_normal_inv_numba(p):
    return math.sqrt(2) * erf_inv_numba(2 * p - 1)

# Numba-friendly confidence_interval_half_width using std_normal_inv_numba
@numba.njit
def confidence_interval_half_width_numba(alpha, sigma, n):
    z_alpha_over_2 = std_normal_inv_numba(1 - alpha / 2)
    half_width = z_alpha_over_2 * (sigma / math.sqrt(n))
    return half_width
